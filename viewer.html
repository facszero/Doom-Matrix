<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Doom ASCII Matrix Viewer</title>
<style>
  html, body { margin:0; background:#000; overflow:hidden; }
  #c { display:block; background:#000; }

  /* HUD opcional (FPS productor, estado) */
  #hud{
    position: fixed;
    left: 8px;
    top: 8px;
    font-family: Consolas, "MS Gothic", "Meiryo", monospace;
    font-size: 12px;
    color: #00ff41;
    text-shadow: 0 0 6px #00ff41;
    user-select: none;
    pointer-events: none;
    opacity: 0.9;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud"></div>

<script>
//// const CHARS_CLASSIC = Array.from(" .:-=+*#%@");
//// const CHARS_CLASSIC = Array.from(".:;-=+*#%@");
const CHARS_CLASSIC = Array.from(" .:-=+*#");
//// const CHARS_MATRIX  = Array.from(" 0123456789ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄ");
const CHARS_MATRIX  = Array.from(".0123456789ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄ");

let mode = "matrix";     // "classic" o "matrix"
//// let scale = 8;           // tamaño de cada “carácter” en px
//// let scale = 7;           // tamaño de cada “carácter” en px
let scale = 6;           // tamaño de cada “carácter” en px
/// let glow = true;

// === BRILLO (para “menos opaco”) ===
// gBoost suma verde base, gGamma hace curva (menor => más brillante)
/// let gBoost = 35;         // 0..80
/// let gBoost = 30;         // 0..80
/// let gGamma = 0.85;       // 0.6..1.2  (menor = más brillante)
/// let gGamma = 0.9;        // 0.6..1.2  (menor = más brillante)
let enemyBoost = 40;     // brillo extra enemigo (además del del servidor)

// ======================================================
// INTERPOLACIÓN VISUAL “MATRIX” (barata, muy efectiva)
// ======================================================
let trails = true;        // estela (clave para que no se “clave”)
/// let trailAlpha = 0.18;    // 0.10..0.30 (más alto = más estela)
let flicker = true;       // micro variación / “vida”
/// let flickerAmp = 14;      // 0..40 (más alto = más Matrix)
let microShift = true;    // jitter 1px para romper “clavado”
let shiftAmp = 1;         // 0..2 px
/// let sprinkle = true;      // “chispas” Matrix cuando no hay frame nuevo
/// let sprinkleN = 90;       // cantidad de chispas por frame render
/// let trailAlpha = 0.20;   // oscurece más cada frame (menos pantalla verde)
let trailAlpha = 0.08;   // oscurece más cada frame (menos pantalla verde)
/// let flickerAmp = 6;      // flicker más sutil
let flickerAmp = 3;      // flicker más sutil
let sprinkle = false;    // por ahora OFF (no tapar Doom)
let sprinkleN = 20;      // (queda por si lo activás)
/// let gBoost = 30;         // menos “lavado” verde permanente
let gBoost = 40;         // menos “lavado” verde permanente
/// let gGamma = 0.90;       // oscurece medios tonos un poco
let gGamma = 0.80;       // oscurece medios tonos un poco
let glow = true;         // ok, pero vamos a bajar shadowBlur

let lastTsDrawn = null;


// HUD
const hud = document.getElementById("hud");
let showHud = true;

// ======================================================

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha: false });

let W = 0, H = 0;
let xPos = null, yPos = null;

function resize(w, h){
  W = w; H = h;
  canvas.width = w * scale;
  canvas.height = h * scale;

  // Fuente (MS Gothic ayuda con katakana)
  ctx.font = `${scale}px Consolas, "MS Gothic", "Meiryo", monospace`;
  ctx.textBaseline = "top";

  // Precomputar posiciones para acelerar
  xPos = new Int32Array(W);
  yPos = new Int32Array(H);
  for(let x=0; x<W; x++) xPos[x] = x * scale;
  for(let y=0; y<H; y++) yPos[y] = y * scale;
}

// Mapea g(0..255) a verde final con boost + gamma
function greenFromG(g, isEnemy, flick=0){
  let v = g + gBoost + (isEnemy ? enemyBoost : 0) + flick;
  if(v > 255) v = 255;
  if(v < 0) v = 0;

  // gamma: normalizar 0..1, aplicar gamma, volver a 0..255
  let f = v / 255;
  f = Math.pow(f, gGamma);
  v = (f * 255) | 0;

  return v;
}

let latest = null;
let fetching = false;
let lastFetch = 0;

// Control de FPS de fetch (no del render)
// 33ms ≈ 30 FPS, 50ms ≈ 20 FPS
//// const FETCH_INTERVAL_MS = 33;
//// const FETCH_INTERVAL_MS = 16; // entorno 60 FPS
const FETCH_INTERVAL_MS = 120; // alineado a productor lento (8-10 FPS típicos)

// Para detectar “frame nuevo”
//// let lastTsDrawn = 0;
let lastTsSeen = 0;
let prodFps = 0;

// Estimación suave de FPS del productor
function updateProducerFps(ts){
  if(!ts) return;
  if(lastTsSeen && ts > lastTsSeen){
    const dt = ts - lastTsSeen;
    const inst = 1 / dt;
    prodFps = prodFps ? (prodFps*0.8 + inst*0.2) : inst;
  }
  lastTsSeen = ts;
}

async function fetchFrame(){
  if(fetching) return;
  const now = performance.now();
  if(now - lastFetch < FETCH_INTERVAL_MS) return;
  lastFetch = now;

  fetching = true;
  try{
    const r = await fetch("frame.json?x=" + Date.now(), { cache:"no-store" });
    const j = await r.json();
    latest = j;
    if(j && j.ts) updateProducerFps(j.ts);
  }catch(e){
    // silenciar errores intermitentes
  }finally{
    fetching = false;
  }
}

function sprinkleMatrix(sx, sy){
  if(!sprinkle) return;
  // chispas baratas para “vida” cuando el frame no cambia
  for(let i=0; i<sprinkleN; i++){
    const x = (Math.random() * W) | 0;
    const y = (Math.random() * H) | 0;
    const ch = CHARS_MATRIX[(Math.random() * CHARS_MATRIX.length) | 0] || ".";
    const g = 150 + ((Math.random() * 90) | 0);
    ctx.fillStyle = `rgb(0,${g},0)`;
    ctx.fillText(ch, xPos[x] + sx, yPos[y] + sy);
  }
}

function draw(){
  requestAnimationFrame(draw);

  // buscar frame nuevo a ritmo controlado
  fetchFrame();

  if(!latest) return;

  const j = latest;
  // ¿hay frame nuevo? (definir SIEMPRE antes de usar)
	const hasNewFrame = (!j.ts)
		? true
		: (lastTsDrawn === null || j.ts !== lastTsDrawn);

  
  if(canvas.width !== j.w * scale || canvas.height !== j.h * scale){
    resize(j.w, j.h);
  }

  const idx = (mode === "classic") ? j.classic : j.matrix;
  const palette = (mode === "classic") ? CHARS_CLASSIC : CHARS_MATRIX;

  // Glow: setear una vez
  if(glow){
    ctx.shadowColor = "#00ff41";
    /// ctx.shadowBlur = Math.max(3, scale);
	ctx.shadowBlur = 0.5;   // o 2 máximo
  } else {
    ctx.shadowBlur = 0;
  }

  // MicroShift: 1px jitter para romper “clavado”
  let sx = 0, sy = 0;
  if(microShift){
    const t = performance.now() * 0.01;
    sx = ((Math.sin(t*1.7) * shiftAmp) | 0);
    sy = ((Math.cos(t*1.3) * shiftAmp) | 0);
  }

  // 1) “Interpolación” visual por estela:
  // En vez de limpiar a negro total, oscurecemos parcialmente.
  /*
  if(trails){
    ctx.save();
    ctx.globalAlpha = trailAlpha;
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  } else {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  */
	// 1) “Interpolación” visual por estela:
	// SOLO oscurecer cuando trails está ON.
	// Si trails OFF, NO limpiar: mantener último frame visible.
	/*
	if(trails){
	  ctx.save();
	  ctx.globalAlpha = trailAlpha;
	  ctx.fillStyle = "#000";
	  ctx.fillRect(0, 0, canvas.width, canvas.height);
	  ctx.restore();
	}
	*/
	// SOLO aplicar estela cuando llega un frame nuevo
	if(trails && hasNewFrame){
		ctx.save();
		ctx.globalAlpha = trailAlpha;
		ctx.fillStyle = "#000";
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		ctx.restore();
	}

  

  // ¿hay frame nuevo?
  /// const hasNewFrame = (j.ts && j.ts !== lastTsDrawn);
  // ¿hay frame nuevo?  (CALCULAR ANTES DE USAR)
  /// const hasNewFrame = (!j.ts) ? true : (lastTsDrawn === null || j.ts !== lastTsDrawn);

  // Glow: setear una vez
  if(glow){
    ctx.shadowColor = "#00ff41";
    ctx.shadowBlur = 2; // fijo y bajo (más legible, menos “apagado”)
  } else {
    ctx.shadowBlur = 0;
  }

  // SOLO aplicar estela cuando llega un frame nuevo
  if(trails && hasNewFrame){
    ctx.save();
    ctx.globalAlpha = trailAlpha;
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }

  // Si NO hay frame nuevo, no redibujar todo → opcional: chispas (si las activás)
  if(!hasNewFrame){
    if(flicker) sprinkleMatrix(sx, sy);

    if(showHud){
      hud.textContent =
        `mode:${mode}  prod:${prodFps.toFixed(1)}fps  fetch:${(1000/FETCH_INTERVAL_MS).toFixed(1)}fps  ` +
        `trails:${trails?'on':'off'} flicker:${flicker?'on':'off'} glow:${glow?'on':'off'}`;
    } else {
      hud.textContent = "";
    }
    return;
  }

  // Frame nuevo: a partir de acá sí dibujamos todo
  lastTsDrawn = j.ts;


  // Frame nuevo: dibujar completo
  for(let y=0; y<H; y++){
    const rowBase = y * W;
    const py = yPos[y] + sy;

    for(let x=0; x<W; x++){
      const k = rowBase + x;
      const ch = palette[idx[k]] || " ";
      const isEnemy = (j.enemy && j.enemy[k] === 1);

      // Flicker por celda (hash barato) para “vida”
      let fl = 0;
      if(flicker){
        const h = (k * 1103515245 + 12345) & 0x7fffffff;
        fl = ((h % (flickerAmp*2 + 1)) - flickerAmp);
      }

      const g = greenFromG(j.g[k], isEnemy, fl);
      ctx.fillStyle = `rgb(0,${g},0)`;
      ctx.fillText(ch, xPos[x] + sx, py);
    }
  }

  if(showHud){
    hud.textContent =
      `mode:${mode}  prod:${prodFps.toFixed(1)}fps  fetch:${(1000/FETCH_INTERVAL_MS).toFixed(1)}fps  ` +
      `trails:${trails?'on':'off'} flicker:${flicker?'on':'off'} glow:${glow?'on':'off'}`;
  } else {
    hud.textContent = "";
  }

  // “Neón extra” opcional: segunda pasada muy leve solo para enemigos
  // (queda lindo y no cuesta tanto)
  // if(glow){
  //   ctx.shadowBlur = Math.max(6, scale*1.2);
  //   for(let y=0; y<H; y++){
  //     const rowBase = y * W;
  //     const py = yPos[y] + sy;
  //     for(let x=0; x<W; x++){
  //       const k = rowBase + x;
  //       if(j.enemy[k] !== 1) continue;
  //       const ch = palette[idx[k]] || " ";
  //       ctx.fillStyle = "rgb(0,255,65)";
  //       ctx.fillText(ch, xPos[x] + sx, py);
  //     }
  //   }
  // }
}

draw();

// Alternar dinámicamente: cada 4s cambia modo
setInterval(() => {
  mode = (mode === "matrix") ? "classic" : "matrix";
}, 4000);

// Hotkeys:
// M = toggle mode
// G = glow
// +/- = scale
// [ y ]: brillo arriba/abajo
// { }  : gamma
// T = trails on/off
// F = flicker on/off
// J = microShift on/off
// H = HUD on/off
window.addEventListener("keydown", (ev) => {
  const k = ev.key.toLowerCase();
  if(k === "m") mode = (mode === "matrix") ? "classic" : "matrix";
  if(k === "g") glow = !glow;

  if(k === "t") trails = !trails;
  if(k === "f") flicker = !flicker;
  if(k === "j") microShift = !microShift;
  if(k === "h") showHud = !showHud;

  if(ev.key === "+"){ scale = Math.min(20, scale+1); if(latest) resize(latest.w, latest.h); }
  if(ev.key === "-"){ scale = Math.max(4, scale-1);  if(latest) resize(latest.w, latest.h); }

  if(k === "[") gBoost = Math.max(0, gBoost - 5);
  if(k === "]") gBoost = Math.min(120, gBoost + 5);

  if(k === "{") gGamma = Math.max(0.5, +(gGamma - 0.05).toFixed(2));
  if(k === "}") gGamma = Math.min(1.3, +(gGamma + 0.05).toFixed(2));
});
</script>
</body>
</html>
